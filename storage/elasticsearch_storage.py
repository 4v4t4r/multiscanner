'''
Storage module that will interact with elasticsearch.
'''
from uuid import uuid4
from elasticsearch import Elasticsearch, helpers
from elasticsearch.client import IndicesClient

import storage

class ElasticSearchStorage(storage.Storage):
    '''
    Subclass of Storage.
    '''
    DEFAULTCONF = {
        'ENABLED': False,
        'host': 'localhost',
        'port': 9200,
        'index': 'multiscanner_reports',
        'doc_type': 'report',
    }

    def setup(self):
        self.host = self.config['host']
        self.port = self.config['port']
        self.index = self.config['index']
        self.doc_type = self.config['doc_type']
        self.es = Elasticsearch(
            host=self.host,
            port=self.port
        )

        # Create parent-child mappings
        es_indices = IndicesClient(self.es)
        mappings = es_indices.get_mapping(index=self.index)
        if self.doc_type not in mappings[self.index]['mappings'].keys():
            es_indices.put_mapping(doc_type=self.doc_type, body={
                '_parent': {
                    'type': 'sample'
                }
            })
        if 'note' not in mappings[self.index]['mappings'].keys():
            es_indices.put_mapping(doc_type='note', body={
                '_parent': {
                    'type': 'sample'
                }
            })

        return True

    def store(self, report):
        sample_id_list = []
        sample_list = []
        report_list = []

        for filename in report:
            report[filename]['filename'] = filename
            try:
                sample_id = report[filename]['SHA256']
            except KeyError:
                sample_id = uuid4()
            sample_id_list.append(sample_id)

            report_id = report[filename]['report_id']
            del report[filename]['report_id']

            # Extract metadata about the sample
            sample = {'filename': filename}
            if 'MD5' in report[filename]:
                sample['md5'] = report[filename]['MD5']
                del report[filename]['MD5']
            if 'SHA1' in report[filename]:
                sample['sha1'] = report[filename]['SHA1']
                del report[filename]['SHA1']
            if 'SHA256' in report[filename]:
                sample['sha256'] = report[filename]['SHA256']
                del report[filename]['SHA256']
            if 'ssdeep' in report[filename]:
                sample['ssdeep'] = report[filename]['ssdeep']
                del report[filename]['ssdeep']

            # TODO: Use ES's autogenerated IDs instead of UUID; better tailored for parallelization
            sample_list.append(
                {
                    '_index': self.index,
                    '_type': 'sample',
                    '_id': sample_id,
                    '_source': sample
                }
            )
            report_list.append(
                {
                    '_index': self.index,
                    '_type': self.doc_type,
                    '_id': report_id,
                    '_parent': sample_id,
                    '_source': report[filename]
                }
            )

        result = helpers.bulk(self.es, sample_list)
        result2 = helpers.bulk(self.es, report_list)
        return sample_id_list

    def get_report(self, sample_id, report_id):
        try:
            result_sample = self.es.get(
                index=self.index, doc_type='sample',
                id=sample_id
            )
            result_report = self.es.get(
                index=self.index, doc_type=self.doc_type,
                id=report_id, parent=sample_id
            )
            result = result_report['_source'].copy()
            result.update(result_sample['_source'])
            return result
        except:
            return None

    def delete(self, report_id):
        try:
            self.es.delete(
                index=self.index, doc_type=self.doc_type,
                id=report_id
            )
            return True
        except:
            return False

    def teardown(self):
        pass
